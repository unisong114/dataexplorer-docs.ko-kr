---
title: 익스텐트 (데이터 분할)-Azure 데이터 탐색기
description: 이 문서에서는 Azure 데이터 탐색기의 익스텐트 (데이터 분할)에 대해 설명 합니다.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/13/2020
ms.openlocfilehash: 2ad77b1763c8f4d85d676b34039a9300fca5912d
ms.sourcegitcommit: 7fa9d0eb3556c55475c95da1f96801e8a0aa6b0f
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/11/2020
ms.locfileid: "91941845"
---
# <a name="extents-data-shards"></a>익스텐트 (데이터 분할)

## <a name="overview"></a>개요

Kusto는 많은 수의 레코드 (행)와 많은 양의 데이터가 포함 된 테이블을 지원 하기 위해 작성 되었습니다. 이러한 많은 테이블을 처리 하기 위해 각 테이블의 데이터는 **데이터 분할** 또는 **익스텐트** 라고 하는 작은 "태블릿"으로 나뉩니다. 두 용어는 동의어입니다. 모든 테이블 익스텐트의 합집합에는 테이블의 데이터가 포함 됩니다. 개별 익스텐트는 단일 노드의 용량 보다 작게 유지 되 고 익스텐트는 클러스터의 노드에 분산 되어 확장을 달성 합니다.

익스텐트는 미니 테이블 형식과 유사 합니다. 여기에는 데이터 및 메타 데이터와 해당 데이터와 연결 된 선택적 태그 및 만든 시간 등의 정보가 포함 됩니다. 또한 익스텐트는 일반적으로 Kusto 데이터를 효율적으로 쿼리할 수 있는 정보를 포함 합니다.
예를 들어 열 데이터가 인코딩 되는 경우 익스텐트의 각 데이터 열에 대 한 인덱스와 인코딩 사전이 있습니다. 결과적으로 테이블의 데이터는 테이블 익스텐트의 모든 데이터의 합집합입니다.

익스텐트는 변경할 수 없으며 수정할 수 없습니다. 쿼리 하거나 다른 노드에 다시 할당 하거나 테이블에서 삭제할 수 있습니다. 하나 이상의 새 범위를 만들고 이전 익스텐트를 새 익스텐트로 교환 하 여 데이터 수정이 발생 합니다.

익스텐트는 열에 물리적으로 정렬 된 레코드의 컬렉션을 보유 합니다.
이 기술을 **칼럼 형식 저장소**라고 합니다. 같은 열에 있는 서로 다른 값이 서로 "유사" 하는 경우가 많기 때문에 데이터를 효율적으로 인코딩하고 압축할 수 있습니다. 또한 쿼리에서 사용 되는 열만 로드 해야 하므로 많은 양의 데이터를 더 효율적으로 쿼리할 수 있습니다. 내부적으로 범위에 있는 데이터의 각 열은 세그먼트로 분할 되 고 세그먼트는 블록으로 나뉩니다. 이 나누기는 쿼리에 대해 관찰 가능 하지 않으며, Kusto 열 압축과 인덱싱을 최적화할 수 있습니다.

쿼리 효율성을 유지 하기 위해 더 작은 익스텐트는 더 큰 범위로 병합 됩니다.
병합은 구성 된 [병합 정책과](mergepolicy.md) [분할 정책](shardingpolicy.md)에 따라 백그라운드 프로세스로 자동으로 수행 됩니다.
익스텐트를 병합 하면 추적할 익스텐트의 수가 증가 하는 관리 오버 헤드가 줄어듭니다. 무엇 보다도 Kusto는 인덱스를 최적화 하 고 압축을 향상 시킬 수 있습니다.

익스텐트 병합은 특정 지점을 벗어나 크기와 같은 특정 한도에 도달 하면 중지 되며, 병합은 효율성이 향상 되는 것이 아니라 축소 됩니다.

테이블에 [데이터 분할 정책이](partitioningpolicy.md) 정의 된 경우 익스텐트는 생성 (사후 수집) 된 후에 다른 백그라운드 프로세스를 진행 합니다. 이 프로세스는 원본 익스텐트의 데이터를 reingests 하 고, 테이블의 *파티션 키* 인 열의 값이 모두 동일한 파티션에 속하는 *동일한 범위를* 만듭니다. 정책에 *해시 파티션 키*가 포함 된 경우 동일한 파티션에 속하는 모든 유형이 같은 익스텐트가 클러스터의 동일한 데이터 노드에 할당 됩니다.

> [!NOTE]
> 익스텐트 태그를 병합 하거나 변경 하는 등의 익스텐트 수준 작업은 기존 익스텐트를 수정 하지 않습니다.
> 대신 기존 원본 범위에 따라 이러한 작업에서 새 익스텐트가 생성 됩니다. 새 익스텐트는 해당 forefathers를 단일 트랜잭션으로 바꿉니다.

일반적인 익스텐트 수명 주기는 다음과 같습니다.

1. 익스텐트 **는 수집 작업에** 의해 생성 됩니다.
1. 범위가 다른 범위와 병합 됩니다. 병합 되는 익스텐트가 작은 경우 Kusto는 실제로 **다시 빌드**라는 수집 프로세스를 수행 합니다. 익스텐트가 특정 크기에 도달 하면 인덱스에 대해서만 병합이 수행 됩니다. 저장소의 익스텐트 데이터 아티팩트가 수정 되지 않습니다.
1. 병합 된 익스텐트 (다른 병합 된 범위에 대 한 계보를 추적 하는 일 수 있음)는 보존 정책 때문에 결국 삭제 됩니다. 
   익스텐트를 삭제할 때 시간 (이전 x 시간/일)에 따라 병합 된 항목 내에서 최신 익스텐트의 생성 날짜가 계산에 사용 됩니다.

## <a name="extent-creation-time"></a>익스텐트 생성 시간

각 익스텐트에 대 한 중요 한 정보 중 하나는 생성 시간입니다. 이 시간은 다음에 사용 됩니다.

1. **보존** -앞에서 만든 익스텐트가 이전에 삭제 됩니다.
1. **캐싱** -최근에 만든 익스텐트가 [핫 캐시](cachepolicy.md)에 보관 됩니다.
1. **샘플링** -최신 익스텐트는와 같은 쿼리 작업을 사용할 때 선호 됩니다. `take`

실제로 Kusto는 `datetime` 익스텐트 및의 두 값을 추적 `MinCreatedOn` `MaxCreatedOn` 합니다.
처음에는 두 값이 동일 합니다. 범위가 다른 범위와 병합 되 면 새 값은 병합 된 익스텐트의 원래 최소값 및 최대값에 따라 만들어집니다.

일반적으로 익스텐트의 생성 시간은 익스텐트의 데이터가 수집 된 시간에 따라 설정 됩니다. 클라이언트는 수집 [속성](../../ingestion-properties.md)에서 대체 생성 시간을 제공 하 여 익스텐트의 생성 시간을 선택적으로 덮어쓸 수 있습니다.
예를 들어, 클라이언트에서 데이터를 다시 수집 하려고 하지만 늦게 도착 한 것 처럼 표시 하지 않으려는 경우에는이를 덮어쓰는 것이 유용 합니다.

## <a name="extent-tagging"></a>익스텐트 태깅

Kusto는 여러 개의 선택적 *익스텐트 태그* 를 해당 메타 데이터의 일부로 범위에 연결 하는 것을 지원 합니다. 익스텐트 태그 (또는 간단히 *태그*)는 범위와 연결 된 문자열입니다. [. 익스텐트 표시](extents-commands.md#show-extents) 명령을 사용 하 여 익스텐트와 연결 된 태그를 확인 하 고, 익스텐트의 [()](../query/extenttagsfunction.md) 함수를 사용 하 여 익스텐트의 레코드와 연결 된 태그를 볼 수 있습니다.
익스텐트 태그는 익스텐트의 모든 데이터에 공통적인 속성을 효율적으로 설명 하는 데 사용할 수 있습니다.
예를 들어 수집 중에 익스텐트 태그를 추가 하 고 수집 데이터의 원본을 나타내며 나중에 해당 태그를 사용할 수 있습니다. 익스텐트는 데이터를 설명 하므로 두 개 이상의 병합을 할 때 연결 된 태그도 병합 됩니다. 결과 익스텐트의 태그는 병합 된 익스텐트의 모든 태그의 합집합이 됩니다.

Kusto는 값이 형식 *접두사* *접미사*를 갖는 모든 익스텐트 태그에 특별 한 의미를 할당 합니다. 여기서 *prefix* 는 다음 중 하나입니다.

* `drop-by:`
* `ingest-by:`

### <a name="drop-by-extent-tags"></a>' 드롭다운: ' 익스텐트 태그

접두사로 시작 하는 태그는 `drop-by:` 병합할 다른 범위를 제어 하는 데 사용할 수 있습니다. 지정 된 태그를 포함 하는 익스텐트는 `drop-by:` 함께 병합할 수 있지만 다른 범위와 병합 되지 않습니다. 그런 다음 명령을 실행 하 여 해당 태그에 따라 익스텐트를 삭제할 수 있습니다 `drop-by:` .

예를 들어:

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

#### <a name="performance-notes"></a>성능 정보

* 태그를 과도 하 게 표시 하지 않습니다 `drop-by` . 위에서 언급 한 방식으로 데이터를 삭제 하는 것은 거의 발생 하지 않는 이벤트에 대 한 것입니다. 이는 레코드 수준 데이터를 대체 하기 위한 것이 아니며, 이러한 방식으로 태그가 지정 된 데이터는 많은데 됩니다. 각 레코드 또는 적은 수의 레코드에 대해 다른 태그를 지정 하려고 하면 성능에 심각한 영향을 줄 수 있습니다.
* `drop-by`데이터가 수집 된 후 일정 기간 동안 태그가 필요 하지 않은 경우 [태그를 삭제](extents-commands.md#drop-extent-tags)하는 것이 좋습니다.

### <a name="ingest-by-extent-tags"></a>' 수집 기준: ' 익스텐트 태그

접두사로 시작 하는 태그를 사용 하 여 `ingest-by:` 데이터를 한 번만 수집 수 있습니다. **`ingestIfNotExists`** 이 특정 태그를 가진 익스텐트가 이미 있는 경우 데이터가 수집 되지 않도록 하는 속성 명령을 실행할 수 있습니다 `ingest-by:` .
및에 대 한 값은 모두 `tags` `ingestIfNotExists` JSON으로 직렬화 된 문자열의 배열입니다.

다음 예에서는 데이터를 한 번만 수집. 두 번째 및 세 번째 명령은 아무 작업도 수행 하지 않습니다.

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> 일반적으로 수집 명령은 `ingest-by:` `ingestIfNotExists` 위의 세 번째 명령에 표시 된 것 처럼 동일한 값으로 설정 된 태그와 속성을 모두 포함할 수 있습니다.

#### <a name="performance-notes"></a>성능 정보

* 과도 `ingest-by` 태그는 권장 되지 않습니다.
파이프라인을 공급할 Kusto가 데이터 중복 하는 것으로 알려진 경우 데이터를 Kusto에 수집 하기 전에 가능한 한 이러한 중복을 해결 하는 것이 좋습니다. 또한 kusto로 `ingest-by` 수집 하는 파트가 중복 항목을 포함할 수 있는 경우에만 kusto의 태그를 사용 합니다. 예를 들어 이미 진행 중인 수집 호출과 겹칠 수 있는 재시도 메커니즘이 있습니다. `ingest-by`각 수집 호출에 대해 고유한 태그를 설정 하려고 하면 성능에 심각한 영향을 줄 수 있습니다.
* 이러한 태그가 데이터가 수집 된 후 일정 기간 동안 필요 하지 않은 경우 [익스텐트 태그를 삭제](drop-extent-tags.md)하는 것이 좋습니다.
 
